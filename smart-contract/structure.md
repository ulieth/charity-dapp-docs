# Program Structure

This section provides a detailed overview of how the Anchor program is organized, including file structure, module organization, and code architecture patterns.

## Directory Structure

```
anchor/programs/charity/src/
├── lib.rs                    # Main program entry point and exports
├── instructions/             # All program instructions
│   ├── mod.rs               # Module exports
│   ├── create_charity.rs    # Create charity instruction
│   ├── update_charity.rs    # Update charity instruction
│   ├── donate_sol.rs        # Donation instruction
│   ├── withdraw_donations.rs # Withdrawal instruction
│   ├── pause_donations.rs   # Pause/unpause instruction
│   └── delete_charity.rs    # Delete charity instruction
├── state/                   # Account structures
│   ├── mod.rs              # State module exports
│   ├── charity.rs          # Charity account structure
│   └── donation.rs         # Donation record structure
└── common/                 # Shared utilities
    ├── mod.rs             # Common module exports
    ├── constants.rs       # Program constants
    ├── errors.rs          # Custom error definitions
    └── events.rs          # Event definitions
```

## Main Program Entry Point (`lib.rs`)

```rust
use anchor_lang::prelude::*;

// Program imports
pub mod instructions;
pub mod state;
pub mod common;

// Re-exports for cleaner imports
pub use instructions::*;
pub use state::*;
pub use common::*;

// Program ID (generated by Anchor)
declare_id!("CHARITY_PROGRAM_ID_HERE");

#[program]
pub mod charity {
    use super::*;

    /// Create a new charity account
    pub fn create_charity(
        ctx: Context<CreateCharity>,
        name: String,
        description: String,
    ) -> Result<()> {
        instructions::create_charity::handler(ctx, name, description)
    }

    /// Update charity description
    pub fn update_charity(
        ctx: Context<UpdateCharity>,
        description: String,
    ) -> Result<()> {
        instructions::update_charity::handler(ctx, description)
    }

    /// Donate SOL to a charity
    pub fn donate_sol(
        ctx: Context<DonateSol>,
        amount: u64,
    ) -> Result<()> {
        instructions::donate_sol::handler(ctx, amount)
    }

    /// Withdraw donations from charity vault
    pub fn withdraw_donations(
        ctx: Context<WithdrawDonations>,
        amount: u64,
        recipient: Pubkey,
    ) -> Result<()> {
        instructions::withdraw_donations::handler(ctx, amount, recipient)
    }

    /// Pause or unpause donations for a charity
    pub fn pause_donations(
        ctx: Context<PauseDonations>,
        paused: bool,
    ) -> Result<()> {
        instructions::pause_donations::handler(ctx, paused)
    }

    /// Delete a charity and withdraw remaining funds
    pub fn delete_charity(
        ctx: Context<DeleteCharity>,
        recipient: Pubkey,
    ) -> Result<()> {
        instructions::delete_charity::handler(ctx, recipient)
    }
}
```

## Instruction Organization

### Instruction Module (`instructions/mod.rs`)

```rust
// Public instruction handlers
pub mod create_charity;
pub mod update_charity;
pub mod donate_sol;
pub mod withdraw_donations;
pub mod pause_donations;
pub mod delete_charity;

// Re-export instruction contexts
pub use create_charity::*;
pub use update_charity::*;
pub use donate_sol::*;
pub use withdraw_donations::*;
pub use pause_donations::*;
pub use delete_charity::*;
```

### Example Instruction Structure (`instructions/create_charity.rs`)

```rust
use anchor_lang::prelude::*;
use crate::{state::Charity, common::*};

/// Account context for creating a charity
#[derive(Accounts)]
#[instruction(name: String)]
pub struct CreateCharity<'info> {
    /// Charity account to be created
    #[account(
        init,
        payer = authority,
        space = 8 + Charity::INIT_SPACE,
        seeds = [b"charity", authority.key().as_ref(), name.as_bytes()],
        bump
    )]
    pub charity: Account<'info, Charity>,

    /// Vault PDA for storing donations
    #[account(
        init,
        payer = authority,
        space = 0,
        seeds = [b"vault", charity.key().as_ref()],
        bump
    )]
    pub vault: SystemAccount<'info>,

    /// Authority (signer) creating the charity
    #[account(mut)]
    pub authority: Signer<'info>,

    /// System program for account creation
    pub system_program: Program<'info, System>,
}

/// Handler function for create_charity instruction
pub fn handler(
    ctx: Context<CreateCharity>,
    name: String,
    description: String,
) -> Result<()> {
    // Input validation
    require!(
        name.len() >= MIN_NAME_LEN && name.len() <= MAX_NAME_LEN,
        CustomError::InvalidNameLength
    );
    require!(
        description.len() >= MIN_DESCRIPTION_LEN && description.len() <= MAX_DESCRIPTION_LEN,
        CustomError::InvalidDescriptionLength
    );

    // Get current timestamp
    let current_time = Clock::get()?.unix_timestamp;

    // Initialize charity account
    let charity = &mut ctx.accounts.charity;
    charity.authority = ctx.accounts.authority.key();
    charity.name = name.clone();
    charity.description = description.clone();
    charity.donations_in_lamports = 0;
    charity.donation_count = 0;
    charity.paused = false;
    charity.created_at = current_time;
    charity.updated_at = current_time;
    charity.deleted_at = None;
    charity.withdrawn_at = None;
    charity.vault_bump = ctx.bumps.vault;

    // Emit creation event
    emit!(CreateCharityEvent {
        charity_key: charity.key(),
        charity_name: name,
        description,
        authority: ctx.accounts.authority.key(),
        created_at: current_time,
    });

    msg!("Charity '{}' created successfully", charity.name);
    Ok(())
}
```

## State Organization

### State Module (`state/mod.rs`)

```rust
pub mod charity;
pub mod donation;

// Re-export state structures
pub use charity::*;
pub use donation::*;
```

### Charity State Structure (`state/charity.rs`)

```rust
use anchor_lang::prelude::*;

/// Main charity account structure
#[account]
pub struct Charity {
    /// Authority (owner) of the charity
    pub authority: Pubkey,              // 32 bytes
    
    /// Name of the charity (max 50 characters)
    pub name: String,                   // 4 + len bytes
    
    /// Description of the charity (max 200 characters)
    pub description: String,            // 4 + len bytes
    
    /// Total donations received in lamports
    pub donations_in_lamports: u64,     // 8 bytes
    
    /// Number of individual donations
    pub donation_count: u32,            // 4 bytes
    
    /// Whether donations are currently paused
    pub paused: bool,                   // 1 byte
    
    /// Timestamp when charity was created
    pub created_at: i64,                // 8 bytes
    
    /// Timestamp when charity was last updated
    pub updated_at: i64,                // 8 bytes
    
    /// Timestamp when charity was deleted (if applicable)
    pub deleted_at: Option<i64>,        // 9 bytes
    
    /// Timestamp of last withdrawal (if applicable)
    pub withdrawn_at: Option<i64>,      // 9 bytes
    
    /// Bump seed for vault PDA
    pub vault_bump: u8,                 // 1 byte
}

impl Space for Charity {
    const INIT_SPACE: usize = 
        32 +                    // authority
        4 + MAX_NAME_LEN +      // name (String with length prefix)
        4 + MAX_DESCRIPTION_LEN + // description
        8 +                     // donations_in_lamports
        4 +                     // donation_count
        1 +                     // paused
        8 +                     // created_at
        8 +                     // updated_at
        1 + 8 +                 // deleted_at (Option<i64>)
        1 + 8 +                 // withdrawn_at (Option<i64>)
        1;                      // vault_bump
}

impl Charity {
    /// Check if charity is active (not deleted and not paused)
    pub fn is_active(&self) -> bool {
        self.deleted_at.is_none() && !self.paused
    }
    
    /// Check if charity can accept donations
    pub fn can_accept_donations(&self) -> bool {
        self.is_active()
    }
    
    /// Get charity age in seconds
    pub fn age_seconds(&self) -> Result<i64> {
        let current_time = Clock::get()?.unix_timestamp;
        Ok(current_time - self.created_at)
    }
    
    /// Calculate average donation amount
    pub fn average_donation(&self) -> u64 {
        if self.donation_count == 0 {
            0
        } else {
            self.donations_in_lamports / (self.donation_count as u64)
        }
    }
}
```

### Donation Record Structure (`state/donation.rs`)

```rust
use anchor_lang::prelude::*;

/// Individual donation record
#[account]
pub struct Donation {
    /// Public key of the donor
    pub donor_key: Pubkey,              // 32 bytes
    
    /// Public key of the charity receiving the donation
    pub charity_key: Pubkey,            // 32 bytes
    
    /// Name of the charity (for easy reference)
    pub charity_name: String,           // 4 + len bytes
    
    /// Donation amount in lamports
    pub amount_in_lamports: u64,        // 8 bytes
    
    /// Timestamp when donation was made
    pub created_at: i64,                // 8 bytes
}

impl Space for Donation {
    const INIT_SPACE: usize = 
        32 +                    // donor_key
        32 +                    // charity_key
        4 + MAX_NAME_LEN +      // charity_name
        8 +                     // amount_in_lamports
        8;                      // created_at
}

impl Donation {
    /// Convert lamports to SOL for display
    pub fn amount_in_sol(&self) -> f64 {
        self.amount_in_lamports as f64 / 1_000_000_000.0
    }
    
    /// Get donation age in seconds
    pub fn age_seconds(&self) -> Result<i64> {
        let current_time = Clock::get()?.unix_timestamp;
        Ok(current_time - self.created_at)
    }
}
```

## Common Utilities

### Constants (`common/constants.rs`)

```rust
/// Maximum length for charity names
pub const MAX_NAME_LEN: usize = 50;

/// Minimum length for charity names
pub const MIN_NAME_LEN: usize = 1;

/// Maximum length for charity descriptions
pub const MAX_DESCRIPTION_LEN: usize = 200;

/// Minimum length for charity descriptions
pub const MIN_DESCRIPTION_LEN: usize = 1;

/// Maximum donation amount (100 SOL)
pub const MAX_DONATION_AMOUNT: u64 = 100_000_000_000;

/// Minimum donation amount (0.001 SOL)
pub const MIN_DONATION_AMOUNT: u64 = 1_000_000;

/// Lamports per SOL
pub const LAMPORTS_PER_SOL: u64 = 1_000_000_000;

/// Seeds for PDA derivation
pub const CHARITY_SEED: &[u8] = b"charity";
pub const VAULT_SEED: &[u8] = b"vault";
pub const DONATION_SEED: &[u8] = b"donation";
```

### Error Definitions (`common/errors.rs`)

```rust
use anchor_lang::prelude::*;

/// Custom error codes for the charity program
#[error_code]
pub enum CustomError {
    #[msg("Unauthorized: Only charity authority can perform this action")]
    Unauthorized,
    
    #[msg("Invalid name length: Name must be between 1 and 50 characters")]
    InvalidNameLength,
    
    #[msg("Invalid description length: Description must be between 1 and 200 characters")]
    InvalidDescriptionLength,
    
    #[msg("Donations are currently paused for this charity")]
    DonationsPaused,
    
    #[msg("Invalid donation amount: Amount must be greater than 0")]
    InvalidAmount,
    
    #[msg("Donation amount exceeds maximum allowed")]
    ExcessiveDonation,
    
    #[msg("Donation amount below minimum required")]
    InsufficientDonation,
    
    #[msg("Insufficient funds for this operation")]
    InsufficientFunds,
    
    #[msg("Insufficient funds to maintain rent exemption")]
    InsufficientFundsForRent,
    
    #[msg("Withdrawal amount exceeds available balance")]
    ExcessiveWithdrawal,
    
    #[msg("Arithmetic overflow occurred")]
    Overflow,
    
    #[msg("Charity has been deleted")]
    CharityDeleted,
    
    #[msg("Charity not found")]
    CharityNotFound,
    
    #[msg("Invalid recipient address")]
    InvalidRecipient,
    
    #[msg("Operation would violate rent exemption")]
    RentViolation,
}
```

### Event Definitions (`common/events.rs`)

```rust
use anchor_lang::prelude::*;

/// Event emitted when a charity is created
#[event]
pub struct CreateCharityEvent {
    pub charity_key: Pubkey,
    pub charity_name: String,
    pub description: String,
    pub authority: Pubkey,
    pub created_at: i64,
}

/// Event emitted when a donation is made
#[event]
pub struct MakeDonationEvent {
    pub donor_key: Pubkey,
    pub charity_key: Pubkey,
    pub charity_name: String,
    pub amount: u64,
    pub total_donations: u64,
    pub donation_count: u32,
    pub created_at: i64,
}

/// Event emitted when donations are withdrawn
#[event]
pub struct WithdrawDonationsEvent {
    pub charity_key: Pubkey,
    pub charity_name: String,
    pub authority: Pubkey,
    pub recipient: Pubkey,
    pub amount: u64,
    pub remaining_balance: u64,
    pub withdrawn_at: i64,
}

/// Event emitted when charity details are updated
#[event]
pub struct UpdateCharityEvent {
    pub charity_key: Pubkey,
    pub charity_name: String,
    pub old_description: String,
    pub new_description: String,
    pub authority: Pubkey,
    pub updated_at: i64,
}

/// Event emitted when donations are paused/unpaused
#[event]
pub struct PauseDonationsEvent {
    pub charity_key: Pubkey,
    pub charity_name: String,
    pub authority: Pubkey,
    pub paused: bool,
    pub timestamp: i64,
}

/// Event emitted when a charity is deleted
#[event]
pub struct DeleteCharityEvent {
    pub charity_key: Pubkey,
    pub charity_name: String,
    pub authority: Pubkey,
    pub final_balance: u64,
    pub total_donations_received: u64,
    pub total_donation_count: u32,
    pub deleted_at: i64,
}
```

## Code Organization Patterns

### Handler Pattern
Each instruction follows a consistent pattern:
1. **Context Definition**: Account validation and constraints
2. **Handler Function**: Business logic implementation
3. **Input Validation**: Parameter checking and sanitization
4. **State Updates**: Account data modifications
5. **Event Emission**: Audit trail and notification

### Error Handling Pattern
```rust
// Consistent error handling throughout the program
pub fn example_handler(ctx: Context<ExampleContext>) -> Result<()> {
    // Validate preconditions
    require!(condition1, CustomError::SpecificError1);
    require!(condition2, CustomError::SpecificError2);
    
    // Perform operations with error propagation
    let result = risky_operation()?;
    
    // Update state
    ctx.accounts.account.field = result;
    
    Ok(())
}
```

### PDA Derivation Pattern
```rust
// Consistent PDA seed patterns
pub fn derive_charity_pda(authority: &Pubkey, name: &str) -> (Pubkey, u8) {
    Pubkey::find_program_address(
        &[CHARITY_SEED, authority.as_ref(), name.as_bytes()],
        &crate::ID,
    )
}
```

This structured approach ensures maintainable, secure, and efficient program development while following Anchor framework best practices.